id: 404
pagetitle: 'Fixing uploads with FileSluggy'
alias: 2016/03/fixing-uploads-with-filesluggy
published: 1
parent: 1
introtext: 'When using the media sources API in MODX to upload files, you might run into issues with files being renamed on upload by plugins like FileSluggy and filetranslit. We did. We finally found a fix for our extras, and would like to share the solution with others who might run into the same issue. '
template: 2
menuindex: 246
createdby: 2
publishedon: 1459234800
uri: posts/2016/03/fixing-uploads-with-filesluggy
show_in_tree: 0
properties: '{"contentblocks":{"content":"[{\"layout\":3,\"content\":{\"col1\":[{\"value\":\"<p>At modmore we have 3 extras that use file uploads one way or another: <a href=\\\"https:\/\/www.modmore.com\/contentblocks\/\\\" target=\\\"_blank\\\">ContentBlocks<\/a>, <a href=\\\"https:\/\/www.modmore.com\/redactor\/\\\" target=\\\"_blank\\\">Redactor<\/a> and <a href=\\\"https:\/\/www.modmore.com\/moregallery\/\\\" target=\\\"_blank\\\">MoreGallery<\/a>. The file upload utilities in these extras have all been built with the <a href=\\\"https:\/\/rtfm.modx.com\/revolution\/2.x\/administering-your-site\/media-sources\\\" target=\\\"_blank\\\">Media Sources<\/a> API in MODX, allowing them to support different media source configurations, remote sources like Amazon S3 and plugins that fire on upload.<\/p><p>Unfortunately, some of those plugins change the name of the uploaded file (for sanitisation or SEO purposes) without the media sources exposing that to the upload, and for a long time we''ve been unable of supporting plugins like <a href=\\\"https:\/\/modx.com\/extras\/package\/filesluggy\\\" target=\\\"_blank\\\">FileSluggy<\/a> and <a href=\\\"https:\/\/modx.com\/extras\/package\/filetranslit\\\" target=\\\"_blank\\\">filetranslit<\/a>. <\/p>\",\"field\":2,\"settings\":[]},{\"value\":\"The Problem\",\"level\":\"h2\",\"field\":3,\"settings\":[]},{\"value\":\"<p>In our code, we call <code>$source-&gt;uploadObjectsToContainer()<\/code> with a prepared files array, and the path we determined it should go to inside the media source. The media source, whether that''s the file or Amazon S3 one, then takes care of the actual upload and returns a <code>true<\/code> (successful upload) or <code>false<\/code> (something went wrong). <\/p><p>As the upload happens, the <code>OnFileManagerUpload<\/code> event is fired by MODX, and plugins like FileSluggy are executed. If they determine the filename does not meet their requirements (for example it contains dashes while underscores are preferred, or it contains special characters), the plugin calls <code>$source-&gt;renameObject()<\/code> with a new file name. This is where the problem happens, as our code doesn''t get a message that the file name was changed after upload. So we try to show an image with a name that no longer exists. Broken image. <\/p><p>For a long time we were unable of figuring out a workaround, until some guys from Sterc walked into <a href=\\\"https:\/\/www.modmore.com\/blog\/2015\/modmore-hq-is-moving-in-with-sterc\/\\\" target=\\\"_blank\\\">modmore hq<\/a> to check on the issue. Following a bit of a discussion and some source code digging, an epiphany happened and we finally found a fix. Since then we''ve updated our extras to fix the compatibility. As there might be other people out there (today or in six months from now) that need to deal with the same problem, I''d like to present you our solution. <\/p>\",\"field\":2,\"settings\":[]},{\"value\":\"The Solution\",\"level\":\"h2\",\"field\":3,\"settings\":[]},{\"value\":\"<p>As with all issues that take ages to solve, the solution is pretty simple: listen for renamed files.<\/p><p>In the same fashion that MODX fires an event on upload in <code>$source-&gt;uploadObjectsToContainer()<\/code>, it also fires an event when a file is renamed through <code>$source-&gt;renameObject()<\/code>. We can listen for this event in a plugin, store the updated file name, and check if any file renames happened during the upload. <\/p><p>Here''s how we fixed this, taking ContentBlocks as the example.<\/p>\",\"field\":2,\"settings\":[]},{\"value\":\"Step 1: Add a place to store changed filenames\",\"level\":\"h3\",\"field\":3,\"settings\":[]},{\"value\":\"<p>The most obvious place to store changed file names is on the service class. Pretty much all MODX Extras have one with the same name as the package. As a service class, we can also use <code>$modx-&gt;getService()<\/code> to always get the same instance - rather than creating a new copy every time - so we can store our changed file name there temporarily. <\/p><p>For this purpose we added a simple <code>$renames<\/code> array.<\/p>\",\"field\":2,\"settings\":[]},{\"value\":\"<?php\\n\\nclass ContentBlocks {\\n    public $renames = array();\\n    \\n    public function __construct(modX $modx, array $config = array()) {\\n        \/\/ ...\\n    }\\n}\",\"lang\":\"php\",\"field\":10,\"settings\":[]},{\"value\":\"<p>If you''re feeling fancy, you might add a getter and setter for it, but we just made it public instead.<\/p><p>After adding it to the class we can start interacting with it, however it''s important that we share the same instance across the request. In our case, we had a direct instantiation in <code>assets\/components\/contentblocks\/connector.php<\/code> like this:<\/p>\",\"field\":2,\"settings\":[]},{\"value\":\"<?php\\n\/\/ ...\\n$corePath = $modx->getOption(''contentblocks.core_path'', null, $modx->getOption(''core_path'') . ''components\/contentblocks\/'');\\nrequire_once $corePath.''model\/contentblocks\/contentblocks.class.php'';\\n$modx->contentblocks = new ContentBlocks($modx);\\n\/\/ ...\",\"lang\":\"php\",\"field\":10,\"settings\":[]},{\"value\":\"<p>Elsewhere in the code, such as in our plugin, we were using <code>$modx-&gt;getService<\/code>. The getService call would return a new instance because the earlier instance wasn''t created properly, meaning we would be unable of accessing the file paths added to <code>$contentblocks-&gt;renames<\/code>. <\/p><p>The fix for this was luckily easy, we just had to switch the connector to also use getService. <\/p>\",\"field\":2,\"settings\":[]},{\"value\":\"<?php\\n\/\/ ...\\n$corePath = $modx->getOption(''contentblocks.core_path'', null, $modx->getOption(''core_path'') . ''components\/contentblocks\/'');\\n$modx->getService(''contentblocks'', ''ContentBlocks'', $corePath . ''model\/contentblocks\/'');\\n\/\/ ...\",\"lang\":\"php\",\"field\":10,\"settings\":[]},{\"value\":\"Step 2: Log the file name changes\",\"level\":\"h3\",\"field\":3,\"settings\":[]},{\"value\":\"<p>The next step is to listen to the <code>OnFileManagerFileRename<\/code> system event in MODX, and to log the new file name to our <code>$contentblocks-&gt;renames<\/code> array. To do this, we updated our existing plugin to also listen to that event and simply added the following to the code:<\/p>\",\"field\":2,\"settings\":[]},{\"value\":\"<?php\\n$corePath = $modx->getOption(''contentblocks.core_path'', null, $modx->getOption(''core_path'') . ''components\/contentblocks\/'');\\n$contentblocks = $modx->getService(''contentblocks'', ''ContentBlocks'', $corePath . ''model\/contentblocks\/'');\\n\\nswitch ($modx->event->name) {\\n    case ''OnFileManagerFileRename'':\\n        $contentblocks->renames[] = $path;\\n        break;\\n        \\n    \/\/ ...\\n}\\n\",\"lang\":\"php\",\"field\":10,\"settings\":[]},{\"value\":\"<p><code>$path<\/code> contains the new path to the file. This way, whenever a file is renamed, ContentBlocks is made aware of it. <\/p>\",\"field\":2,\"settings\":[]},{\"value\":\"Step 3: Updating the Upload Code\",\"level\":\"h3\",\"field\":3,\"settings\":[]},{\"value\":\"<p>The third, and final, step is to update the upload code to check for file renames. Here''s what that looks like for ContentBlocks:<\/p>\",\"field\":2,\"settings\":[]},{\"value\":\"<?php\\n\\nclass ContentBlocksImageUploadProcessor extends ContentBlocksImageProcessor {\\n    \/**\\n     * @return bool\\n     *\/\\n    public function process() {\\n        \/\/ ... bunch of preprocessing here\\n        \\n        \/**\\n         * Do the upload\\n         *\/\\n        $this->contentblocks->renames = array();\\n        $uploaded = $this->source->uploadObjectsToContainer($this->path, $_FILES);\\n        if (!$uploaded) {\\n            $errors = $this->source->getErrors();\\n            $errors = implode(''<br \/>'', $errors);\\n            return $this->failure($errors);\\n        }\\n        \/**\\n         * Check if the file has been renamed by a plugin like FileSluggy\\n         *\/\\n        $newFileName = reset($this->contentblocks->renames);\\n        if (!empty($newFileName)) {\\n            $baseMediaPath = $this->source->getBasePath() . $this->path;\\n            $newFileName = substr($newFileName, strlen($baseMediaPath));\\n            $_FILES[''file''][''name''] = $newFileName;\\n        }\\n        \\n        \/\/ ... and more processing here\\n    }\\n}\",\"lang\":\"php\",\"field\":10,\"settings\":[]},{\"value\":\"<p>Obviously this is just a small snippet of the upload processor, and this exact logic might vary greatly between extras. Even though <a href=\\\"https:\/\/www.modmore.com\/blog\/2016\/introducing-alpacka\/\\\" target=\\\"_blank\\\">we''ve been standardising our code<\/a>, even between our own extras there are big differences in how uploads are handled. <\/p><p>The basic gist of how this works is to ensure the renames array is empty (<code>$this-&gt;contentblocks-&gt;renames = array()<\/code>) before calling <code>$this-&gt;source-&gt;uploadObjectsToContainer()<\/code>, and then after the upload see if any file names were changed. <\/p><p>In ContentBlocks, we refer to the information in the <code>$_FILES<\/code> superglobal further down in the processor to get the full file url, so we just need to update that with the new file name. If your code has something like an url variable that you return, you''ll need to fix that based on the path from <code>$this-&gt;contentblocks-&gt;renames<\/code>. <\/p>\",\"field\":2,\"settings\":[]},{\"value\":\"Conclusion\",\"level\":\"h2\",\"field\":3,\"settings\":[]},{\"value\":\"<p>Sometimes all it takes to get past a longstanding issue is to discuss it with others, and a bit of creativity. <\/p>\",\"field\":2,\"settings\":[]}]},\"settings\":[],\"parent\":0,\"title\":\"\"}]","linear":[{"value":"<p>At modmore we have 3 extras that use file uploads one way or another: <a href=\"https:\/\/www.modmore.com\/contentblocks\/\" target=\"_blank\">ContentBlocks<\/a>, <a href=\"https:\/\/www.modmore.com\/redactor\/\" target=\"_blank\">Redactor<\/a> and <a href=\"https:\/\/www.modmore.com\/moregallery\/\" target=\"_blank\">MoreGallery<\/a>. The file upload utilities in these extras have all been built with the <a href=\"https:\/\/rtfm.modx.com\/revolution\/2.x\/administering-your-site\/media-sources\" target=\"_blank\">Media Sources<\/a> API in MODX, allowing them to support different media source configurations, remote sources like Amazon S3 and plugins that fire on upload.<\/p><p>Unfortunately, some of those plugins change the name of the uploaded file (for sanitisation or SEO purposes) without the media sources exposing that to the upload, and for a long time we''ve been unable of supporting plugins like <a href=\"https:\/\/modx.com\/extras\/package\/filesluggy\" target=\"_blank\">FileSluggy<\/a> and <a href=\"https:\/\/modx.com\/extras\/package\/filetranslit\" target=\"_blank\">filetranslit<\/a>. <\/p>","field":2,"settings":[]},{"value":"The Problem","level":"h2","field":3,"settings":[]},{"value":"<p>In our code, we call <code>$source-&gt;uploadObjectsToContainer()<\/code> with a prepared files array, and the path we determined it should go to inside the media source. The media source, whether that''s the file or Amazon S3 one, then takes care of the actual upload and returns a <code>true<\/code> (successful upload) or <code>false<\/code> (something went wrong). <\/p><p>As the upload happens, the <code>OnFileManagerUpload<\/code> event is fired by MODX, and plugins like FileSluggy are executed. If they determine the filename does not meet their requirements (for example it contains dashes while underscores are preferred, or it contains special characters), the plugin calls <code>$source-&gt;renameObject()<\/code> with a new file name. This is where the problem happens, as our code doesn''t get a message that the file name was changed after upload. So we try to show an image with a name that no longer exists. Broken image. <\/p><p>For a long time we were unable of figuring out a workaround, until some guys from Sterc walked into <a href=\"https:\/\/www.modmore.com\/blog\/2015\/modmore-hq-is-moving-in-with-sterc\/\" target=\"_blank\">modmore hq<\/a> to check on the issue. Following a bit of a discussion and some source code digging, an epiphany happened and we finally found a fix. Since then we''ve updated our extras to fix the compatibility. As there might be other people out there (today or in six months from now) that need to deal with the same problem, I''d like to present you our solution. <\/p>","field":2,"settings":[]},{"value":"The Solution","level":"h2","field":3,"settings":[]},{"value":"<p>As with all issues that take ages to solve, the solution is pretty simple: listen for renamed files.<\/p><p>In the same fashion that MODX fires an event on upload in <code>$source-&gt;uploadObjectsToContainer()<\/code>, it also fires an event when a file is renamed through <code>$source-&gt;renameObject()<\/code>. We can listen for this event in a plugin, store the updated file name, and check if any file renames happened during the upload. <\/p><p>Here''s how we fixed this, taking ContentBlocks as the example.<\/p>","field":2,"settings":[]},{"value":"Step 1: Add a place to store changed filenames","level":"h3","field":3,"settings":[]},{"value":"<p>The most obvious place to store changed file names is on the service class. Pretty much all MODX Extras have one with the same name as the package. As a service class, we can also use <code>$modx-&gt;getService()<\/code> to always get the same instance - rather than creating a new copy every time - so we can store our changed file name there temporarily. <\/p><p>For this purpose we added a simple <code>$renames<\/code> array.<\/p>","field":2,"settings":[]},{"value":"<?php\n\nclass ContentBlocks {\n    public $renames = array();\n    \n    public function __construct(modX $modx, array $config = array()) {\n        \/\/ ...\n    }\n}","lang":"php","field":10,"settings":[]},{"value":"<p>If you''re feeling fancy, you might add a getter and setter for it, but we just made it public instead.<\/p><p>After adding it to the class we can start interacting with it, however it''s important that we share the same instance across the request. In our case, we had a direct instantiation in <code>assets\/components\/contentblocks\/connector.php<\/code> like this:<\/p>","field":2,"settings":[]},{"value":"<?php\n\/\/ ...\n$corePath = $modx->getOption(''contentblocks.core_path'', null, $modx->getOption(''core_path'') . ''components\/contentblocks\/'');\nrequire_once $corePath.''model\/contentblocks\/contentblocks.class.php'';\n$modx->contentblocks = new ContentBlocks($modx);\n\/\/ ...","lang":"php","field":10,"settings":[]},{"value":"<p>Elsewhere in the code, such as in our plugin, we were using <code>$modx-&gt;getService<\/code>. The getService call would return a new instance because the earlier instance wasn''t created properly, meaning we would be unable of accessing the file paths added to <code>$contentblocks-&gt;renames<\/code>. <\/p><p>The fix for this was luckily easy, we just had to switch the connector to also use getService. <\/p>","field":2,"settings":[]},{"value":"<?php\n\/\/ ...\n$corePath = $modx->getOption(''contentblocks.core_path'', null, $modx->getOption(''core_path'') . ''components\/contentblocks\/'');\n$modx->getService(''contentblocks'', ''ContentBlocks'', $corePath . ''model\/contentblocks\/'');\n\/\/ ...","lang":"php","field":10,"settings":[]},{"value":"Step 2: Log the file name changes","level":"h3","field":3,"settings":[]},{"value":"<p>The next step is to listen to the <code>OnFileManagerFileRename<\/code> system event in MODX, and to log the new file name to our <code>$contentblocks-&gt;renames<\/code> array. To do this, we updated our existing plugin to also listen to that event and simply added the following to the code:<\/p>","field":2,"settings":[]},{"value":"<?php\n$corePath = $modx->getOption(''contentblocks.core_path'', null, $modx->getOption(''core_path'') . ''components\/contentblocks\/'');\n$contentblocks = $modx->getService(''contentblocks'', ''ContentBlocks'', $corePath . ''model\/contentblocks\/'');\n\nswitch ($modx->event->name) {\n    case ''OnFileManagerFileRename'':\n        $contentblocks->renames[] = $path;\n        break;\n        \n    \/\/ ...\n}\n","lang":"php","field":10,"settings":[]},{"value":"<p><code>$path<\/code> contains the new path to the file. This way, whenever a file is renamed, ContentBlocks is made aware of it. <\/p>","field":2,"settings":[]},{"value":"Step 3: Updating the Upload Code","level":"h3","field":3,"settings":[]},{"value":"<p>The third, and final, step is to update the upload code to check for file renames. Here''s what that looks like for ContentBlocks:<\/p>","field":2,"settings":[]},{"value":"<?php\n\nclass ContentBlocksImageUploadProcessor extends ContentBlocksImageProcessor {\n    \/**\n     * @return bool\n     *\/\n    public function process() {\n        \/\/ ... bunch of preprocessing here\n        \n        \/**\n         * Do the upload\n         *\/\n        $this->contentblocks->renames = array();\n        $uploaded = $this->source->uploadObjectsToContainer($this->path, $_FILES);\n        if (!$uploaded) {\n            $errors = $this->source->getErrors();\n            $errors = implode(''<br \/>'', $errors);\n            return $this->failure($errors);\n        }\n        \/**\n         * Check if the file has been renamed by a plugin like FileSluggy\n         *\/\n        $newFileName = reset($this->contentblocks->renames);\n        if (!empty($newFileName)) {\n            $baseMediaPath = $this->source->getBasePath() . $this->path;\n            $newFileName = substr($newFileName, strlen($baseMediaPath));\n            $_FILES[''file''][''name''] = $newFileName;\n        }\n        \n        \/\/ ... and more processing here\n    }\n}","lang":"php","field":10,"settings":[]},{"value":"<p>Obviously this is just a small snippet of the upload processor, and this exact logic might vary greatly between extras. Even though <a href=\"https:\/\/www.modmore.com\/blog\/2016\/introducing-alpacka\/\" target=\"_blank\">we''ve been standardising our code<\/a>, even between our own extras there are big differences in how uploads are handled. <\/p><p>The basic gist of how this works is to ensure the renames array is empty (<code>$this-&gt;contentblocks-&gt;renames = array()<\/code>) before calling <code>$this-&gt;source-&gt;uploadObjectsToContainer()<\/code>, and then after the upload see if any file names were changed. <\/p><p>In ContentBlocks, we refer to the information in the <code>$_FILES<\/code> superglobal further down in the processor to get the full file url, so we just need to update that with the new file name. If your code has something like an url variable that you return, you''ll need to fix that based on the path from <code>$this-&gt;contentblocks-&gt;renames<\/code>. <\/p>","field":2,"settings":[]},{"value":"Conclusion","level":"h2","field":3,"settings":[]},{"value":"<p>Sometimes all it takes to get past a longstanding issue is to discuss it with others, and a bit of creativity. <\/p>","field":2,"settings":[]}],"fieldcounts":{"2":11,"3":6,"10":5},"_isContentBlocks":true}}'
tvs:
    author: markhamstra
    disqus_id: ''
    page_head: ''
    preview.image: ''

-----

<div class="row   " >
    <div class="[[++default_article_column_classnames]]">
        <p>At modmore we have 3 extras that use file uploads one way or another: <a href="https://www.modmore.com/contentblocks/" target="_blank">ContentBlocks</a>, <a href="https://www.modmore.com/redactor/" target="_blank">Redactor</a> and <a href="https://www.modmore.com/moregallery/" target="_blank">MoreGallery</a>. The file upload utilities in these extras have all been built with the <a href="https://rtfm.modx.com/revolution/2.x/administering-your-site/media-sources" target="_blank">Media Sources</a> API in MODX, allowing them to support different media source configurations, remote sources like Amazon S3 and plugins that fire on upload.</p><p>Unfortunately, some of those plugins change the name of the uploaded file (for sanitisation or SEO purposes) without the media sources exposing that to the upload, and for a long time we've been unable of supporting plugins like <a href="https://modx.com/extras/package/filesluggy" target="_blank">FileSluggy</a> and <a href="https://modx.com/extras/package/filetranslit" target="_blank">filetranslit</a>. </p>

<h2>The Problem</h2>

<p>In our code, we call <code>$source-&gt;uploadObjectsToContainer()</code> with a prepared files array, and the path we determined it should go to inside the media source. The media source, whether that's the file or Amazon S3 one, then takes care of the actual upload and returns a <code>true</code> (successful upload) or <code>false</code> (something went wrong). </p><p>As the upload happens, the <code>OnFileManagerUpload</code> event is fired by MODX, and plugins like FileSluggy are executed. If they determine the filename does not meet their requirements (for example it contains dashes while underscores are preferred, or it contains special characters), the plugin calls <code>$source-&gt;renameObject()</code> with a new file name. This is where the problem happens, as our code doesn't get a message that the file name was changed after upload. So we try to show an image with a name that no longer exists. Broken image. </p><p>For a long time we were unable of figuring out a workaround, until some guys from Sterc walked into <a href="https://www.modmore.com/blog/2015/modmore-hq-is-moving-in-with-sterc/" target="_blank">modmore hq</a> to check on the issue. Following a bit of a discussion and some source code digging, an epiphany happened and we finally found a fix. Since then we've updated our extras to fix the compatibility. As there might be other people out there (today or in six months from now) that need to deal with the same problem, I'd like to present you our solution. </p>

<h2>The Solution</h2>

<p>As with all issues that take ages to solve, the solution is pretty simple: listen for renamed files.</p><p>In the same fashion that MODX fires an event on upload in <code>$source-&gt;uploadObjectsToContainer()</code>, it also fires an event when a file is renamed through <code>$source-&gt;renameObject()</code>. We can listen for this event in a plugin, store the updated file name, and check if any file renames happened during the upload. </p><p>Here's how we fixed this, taking ContentBlocks as the example.</p>

<h3>Step 1: Add a place to store changed filenames</h3>

<p>The most obvious place to store changed file names is on the service class. Pretty much all MODX Extras have one with the same name as the package. As a service class, we can also use <code>$modx-&gt;getService()</code> to always get the same instance - rather than creating a new copy every time - so we can store our changed file name there temporarily. </p><p>For this purpose we added a simple <code>$renames</code> array.</p>

<pre><code class="language-php">&lt;?php

class ContentBlocks {
    public $renames = array();
    
    public function __construct(modX $modx, array $config = array()) {
        // ...
    }
}</code></pre>

<p>If you're feeling fancy, you might add a getter and setter for it, but we just made it public instead.</p><p>After adding it to the class we can start interacting with it, however it's important that we share the same instance across the request. In our case, we had a direct instantiation in <code>assets/components/contentblocks/connector.php</code> like this:</p>

<pre><code class="language-php">&lt;?php
// ...
$corePath = $modx-&gt;getOption('contentblocks.core_path', null, $modx-&gt;getOption('core_path') . 'components/contentblocks/');
require_once $corePath.'model/contentblocks/contentblocks.class.php';
$modx-&gt;contentblocks = new ContentBlocks($modx);
// ...</code></pre>

<p>Elsewhere in the code, such as in our plugin, we were using <code>$modx-&gt;getService</code>. The getService call would return a new instance because the earlier instance wasn't created properly, meaning we would be unable of accessing the file paths added to <code>$contentblocks-&gt;renames</code>. </p><p>The fix for this was luckily easy, we just had to switch the connector to also use getService. </p>

<pre><code class="language-php">&lt;?php
// ...
$corePath = $modx-&gt;getOption('contentblocks.core_path', null, $modx-&gt;getOption('core_path') . 'components/contentblocks/');
$modx-&gt;getService('contentblocks', 'ContentBlocks', $corePath . 'model/contentblocks/');
// ...</code></pre>

<h3>Step 2: Log the file name changes</h3>

<p>The next step is to listen to the <code>OnFileManagerFileRename</code> system event in MODX, and to log the new file name to our <code>$contentblocks-&gt;renames</code> array. To do this, we updated our existing plugin to also listen to that event and simply added the following to the code:</p>

<pre><code class="language-php">&lt;?php
$corePath = $modx-&gt;getOption('contentblocks.core_path', null, $modx-&gt;getOption('core_path') . 'components/contentblocks/');
$contentblocks = $modx-&gt;getService('contentblocks', 'ContentBlocks', $corePath . 'model/contentblocks/');

switch ($modx-&gt;event-&gt;name) {
    case 'OnFileManagerFileRename':
        $contentblocks-&gt;renames&#91;&#93; = $path;
        break;
        
    // ...
}
</code></pre>

<p><code>$path</code> contains the new path to the file. This way, whenever a file is renamed, ContentBlocks is made aware of it. </p>

<h3>Step 3: Updating the Upload Code</h3>

<p>The third, and final, step is to update the upload code to check for file renames. Here's what that looks like for ContentBlocks:</p>

<pre><code class="language-php">&lt;?php

class ContentBlocksImageUploadProcessor extends ContentBlocksImageProcessor {
    /**
     * @return bool
     */
    public function process() {
        // ... bunch of preprocessing here
        
        /**
         * Do the upload
         */
        $this-&gt;contentblocks-&gt;renames = array();
        $uploaded = $this-&gt;source-&gt;uploadObjectsToContainer($this-&gt;path, $_FILES);
        if (!$uploaded) {
            $errors = $this-&gt;source-&gt;getErrors();
            $errors = implode('&lt;br /&gt;', $errors);
            return $this-&gt;failure($errors);
        }
        /**
         * Check if the file has been renamed by a plugin like FileSluggy
         */
        $newFileName = reset($this-&gt;contentblocks-&gt;renames);
        if (!empty($newFileName)) {
            $baseMediaPath = $this-&gt;source-&gt;getBasePath() . $this-&gt;path;
            $newFileName = substr($newFileName, strlen($baseMediaPath));
            $_FILES&#91;'file'&#93;&#91;'name'&#93; = $newFileName;
        }
        
        // ... and more processing here
    }
}</code></pre>

<p>Obviously this is just a small snippet of the upload processor, and this exact logic might vary greatly between extras. Even though <a href="https://www.modmore.com/blog/2016/introducing-alpacka/" target="_blank">we've been standardising our code</a>, even between our own extras there are big differences in how uploads are handled. </p><p>The basic gist of how this works is to ensure the renames array is empty (<code>$this-&gt;contentblocks-&gt;renames = array()</code>) before calling <code>$this-&gt;source-&gt;uploadObjectsToContainer()</code>, and then after the upload see if any file names were changed. </p><p>In ContentBlocks, we refer to the information in the <code>$_FILES</code> superglobal further down in the processor to get the full file url, so we just need to update that with the new file name. If your code has something like an url variable that you return, you'll need to fix that based on the path from <code>$this-&gt;contentblocks-&gt;renames</code>. </p>

<h2>Conclusion</h2>

<p>Sometimes all it takes to get past a longstanding issue is to discuss it with others, and a bit of creativity. </p>
    </div>
</div>