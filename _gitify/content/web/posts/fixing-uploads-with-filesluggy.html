id: 404
pagetitle: 'Fixing uploads with FileSluggy'
alias: fixing-uploads-with-filesluggy
parent: 1
introtext: ''
template: 2
menuindex: 246
createdby: 2
uri: posts/fixing-uploads-with-filesluggy
show_in_tree: 0
properties: '{"contentblocks":{"content":"[{\"layout\":3,\"content\":{\"col1\":[{\"value\":\"<p>At modmore we have 3 extras that use file uploads one way or another: ContentBlocks, Redactor and MoreGallery. The file upload utilities in these extras have all been built with the Media Sources API in MODX, allowing them to support different media source configurations, remote sources like Amazon S3 and plugins that fire on upload.<\/p><p>Unfortunately, some of those plugins change the name of the uploaded file (for sanitisation or SEO purposes), and for a long time we''ve been unable of supporting those plugins, like FileSluggy and filetranslit. <\/p>\",\"field\":2,\"settings\":[]},{\"value\":\"The Problem\",\"level\":\"h2\",\"field\":3,\"settings\":{}},{\"value\":\"<p>In our code, we call $source-&gt;uploadObjectsToContainer() with a prepared files array, and the path we determined it should go to inside the media source. The media source, whether that''s the file or Amazon S3 one, then takes care of the actual upload and returns a true (successful upload) or false (something went wrong). <\/p><p>As the upload happens, the OnFileManagerUpload event is fired by MODX, and plugins like FileSluggy are executed. If they determine the filename does not meet their requirements (for example it contains dashes, while underscores are preferred), the plugin calls $source-&gt;renameObject() with a new file name. This is where the problem happens, as our code doesn''t get a message that the file name was changed after upload. So we try to show an image with a name that no longer exists. Broken image. <\/p><p>For a long time we were unable of figuring out a workaround, until the guys at Sterc walked into modmore hq to check on the issue. Following a bit of a discussion and some source code digging, an epiphany happened and we finally found a fix. Since then we''ve updated our extras to fix the compatibility. As there might be other people out there (today or in six months from now) that need to deal with the same problem, I''d like to present you our solution. <\/p>\",\"field\":2,\"settings\":{}},{\"value\":\"The Solution\",\"level\":\"h2\",\"field\":3,\"settings\":{}},{\"value\":\"<p>As with all issues that take ages to solve, the solution is pretty simple: listen for renamed files.<\/p><p>In the same fashion that MODX fires an event on upload in $source-&gt;uploadObjectsToContainer(), it also fires an event when a file is renamed through $source-&gt;renameObject(). We can listen for this event in a plugin, store the updated file name, and check if any file renames happened during the upload. <\/p><p>Here''s how we fixed this, taking ContentBlocks as the example.<\/p>\",\"field\":2,\"settings\":{}},{\"value\":\"Step 1: Add a place to store changed filenames\",\"level\":\"h3\",\"field\":3,\"settings\":{}},{\"value\":\"<p>The most obvious place to store changed file names is on the service class. Pretty much all MODX Extras have one with the same name as the package. As a service class, we can also use $modx-&gt;getService() to always get the same instance - rather than creating a new copy every time - so we can store our changed file name there temporarily. <\/p><p>For this purpose we added a simple $renames array.<\/p>\",\"field\":2,\"settings\":{}},{\"value\":\"<?php\\n\\nclass ContentBlocks {\\n    public $renames = array();\\n    \\n    public function __construct(modX $modx, array $config = array()) {\\n        \/\/ ...\\n    }\\n}\",\"lang\":\"php\",\"field\":10,\"settings\":{}},{\"value\":\"<p>If you''re feeling fancy, you might add a getter and setter for it, but we just made it public instead.<\/p><p>After adding it to the class we can start interacting with it, however it''s important that we share the same instance across the request. In our case, we had a direct instantiation in assets\/components\/contentblocks\/connector.php like this:<\/p>\",\"field\":2,\"settings\":{}},{\"value\":\"<?php\\n\/\/ ...\\n$corePath = $modx->getOption(''contentblocks.core_path'', null, $modx->getOption(''core_path'') . ''components\/contentblocks\/'');\\nrequire_once $corePath.''model\/contentblocks\/contentblocks.class.php'';\\n$modx->contentblocks = new ContentBlocks($modx);\\n\/\/ ...\",\"lang\":\"php\",\"field\":10,\"settings\":{}},{\"value\":\"<p>whereas elsewhere in the code, such as in our plugin as we''ll see in a bit, we were using $modx-&gt;getService. The getService call would return a new instance because the earlier instance wasn''t created properly, meaning we would lose data added to $contentblocks-&gt;renames. <\/p><p>The fix for this was luckily easy, we just had to switch the connector to also use getService. <\/p>\",\"field\":2,\"settings\":{}},{\"value\":\"<?php\\n\/\/ ...\\n$corePath = $modx->getOption(''contentblocks.core_path'', null, $modx->getOption(''core_path'') . ''components\/contentblocks\/'');\\n$modx->getService(''contentblocks'', ''ContentBlocks'', $corePath . ''model\/contentblocks\/'');\\n\/\/ ...\",\"lang\":\"php\",\"field\":10,\"settings\":{}},{\"value\":\"Step 2: Log the file name changes\",\"level\":\"h3\",\"field\":3,\"settings\":{}},{\"value\":\"<p>The next step is to listen to the OnFileManagerFileRename system event in MODX, and to log the new file name to our $contentblocks-&gt;renames array. To do this, we updated our existing plugin to also listen to that event and simply added the following to the code:<\/p>\",\"field\":2,\"settings\":{}},{\"value\":\"<?php\\n$corePath = $modx->getOption(''contentblocks.core_path'', null, $modx->getOption(''core_path'') . ''components\/contentblocks\/'');\\n$contentblocks = $modx->getService(''contentblocks'', ''ContentBlocks'', $corePath . ''model\/contentblocks\/'');\\n\\nswitch ($modx->event->name) {\\n    case ''OnFileManagerFileRename'':\\n        $contentblocks->renames[] = $path;\\n        break;\\n        \\n    \/\/ ...\\n}\\n\",\"lang\":\"php\",\"field\":10,\"settings\":{}},{\"value\":\"<p>This way, whenever a file is renamed, ContentBlocks is made aware of it. <\/p>\",\"field\":2,\"settings\":{}},{\"value\":\"Step 3: Updating the Upload Code\",\"level\":\"h3\",\"field\":3,\"settings\":{}},{\"value\":\"<p>The third, and final, step is to update the upload code to check for file renames. Here''s what that looks like for ContentBlocks:<\/p>\",\"field\":2,\"settings\":{}},{\"value\":\"<?php\\n\\nclass ContentBlocksImageUploadProcessor extends ContentBlocksImageProcessor {\\n    \/**\\n     * @return bool\\n     *\/\\n    public function process() {\\n        \/\/ ... bunch of preprocessing here\\n        \\n        \/**\\n         * Do the upload\\n         *\/\\n        $this->contentblocks->renames = array();\\n        $uploaded = $this->source->uploadObjectsToContainer($this->path, $_FILES);\\n        if (!$uploaded) {\\n            $errors = $this->source->getErrors();\\n            $errors = implode(''<br \/>'', $errors);\\n            return $this->failure($errors);\\n        }\\n        \/**\\n         * Check if the file has been renamed by a plugin like FileSluggy\\n         *\/\\n        $newFileName = reset($this->contentblocks->renames);\\n        if (!empty($newFileName)) {\\n            $baseMediaPath = $this->source->getBasePath() . $this->path;\\n            $newFileName = substr($newFileName, strlen($baseMediaPath));\\n            $_FILES[''file''][''name''] = $newFileName;\\n        }\\n        \\n        \/\/ ... and more processing here\\n    }\\n}\",\"lang\":\"php\",\"field\":10,\"settings\":{}},{\"value\":\"<p>Obviously this is just a small snippet of the upload processor. The key lines are<\/p>\",\"field\":2,\"settings\":{}}]},\"settings\":[],\"parent\":0,\"title\":\"\"}]","linear":[{"value":"<p>At modmore we have 3 extras that use file uploads one way or another: ContentBlocks, Redactor and MoreGallery. The file upload utilities in these extras have all been built with the Media Sources API in MODX, allowing them to support different media source configurations, remote sources like Amazon S3 and plugins that fire on upload.<\/p><p>Unfortunately, some of those plugins change the name of the uploaded file (for sanitisation or SEO purposes), and for a long time we''ve been unable of supporting those plugins, like FileSluggy and filetranslit. <\/p>","field":2,"settings":[]},{"value":"The Problem","level":"h2","field":3,"settings":[]},{"value":"<p>In our code, we call $source-&gt;uploadObjectsToContainer() with a prepared files array, and the path we determined it should go to inside the media source. The media source, whether that''s the file or Amazon S3 one, then takes care of the actual upload and returns a true (successful upload) or false (something went wrong). <\/p><p>As the upload happens, the OnFileManagerUpload event is fired by MODX, and plugins like FileSluggy are executed. If they determine the filename does not meet their requirements (for example it contains dashes, while underscores are preferred), the plugin calls $source-&gt;renameObject() with a new file name. This is where the problem happens, as our code doesn''t get a message that the file name was changed after upload. So we try to show an image with a name that no longer exists. Broken image. <\/p><p>For a long time we were unable of figuring out a workaround, until the guys at Sterc walked into modmore hq to check on the issue. Following a bit of a discussion and some source code digging, an epiphany happened and we finally found a fix. Since then we''ve updated our extras to fix the compatibility. As there might be other people out there (today or in six months from now) that need to deal with the same problem, I''d like to present you our solution. <\/p>","field":2,"settings":[]},{"value":"The Solution","level":"h2","field":3,"settings":[]},{"value":"<p>As with all issues that take ages to solve, the solution is pretty simple: listen for renamed files.<\/p><p>In the same fashion that MODX fires an event on upload in $source-&gt;uploadObjectsToContainer(), it also fires an event when a file is renamed through $source-&gt;renameObject(). We can listen for this event in a plugin, store the updated file name, and check if any file renames happened during the upload. <\/p><p>Here''s how we fixed this, taking ContentBlocks as the example.<\/p>","field":2,"settings":[]},{"value":"Step 1: Add a place to store changed filenames","level":"h3","field":3,"settings":[]},{"value":"<p>The most obvious place to store changed file names is on the service class. Pretty much all MODX Extras have one with the same name as the package. As a service class, we can also use $modx-&gt;getService() to always get the same instance - rather than creating a new copy every time - so we can store our changed file name there temporarily. <\/p><p>For this purpose we added a simple $renames array.<\/p>","field":2,"settings":[]},{"value":"<?php\n\nclass ContentBlocks {\n    public $renames = array();\n    \n    public function __construct(modX $modx, array $config = array()) {\n        \/\/ ...\n    }\n}","lang":"php","field":10,"settings":[]},{"value":"<p>If you''re feeling fancy, you might add a getter and setter for it, but we just made it public instead.<\/p><p>After adding it to the class we can start interacting with it, however it''s important that we share the same instance across the request. In our case, we had a direct instantiation in assets\/components\/contentblocks\/connector.php like this:<\/p>","field":2,"settings":[]},{"value":"<?php\n\/\/ ...\n$corePath = $modx->getOption(''contentblocks.core_path'', null, $modx->getOption(''core_path'') . ''components\/contentblocks\/'');\nrequire_once $corePath.''model\/contentblocks\/contentblocks.class.php'';\n$modx->contentblocks = new ContentBlocks($modx);\n\/\/ ...","lang":"php","field":10,"settings":[]},{"value":"<p>whereas elsewhere in the code, such as in our plugin as we''ll see in a bit, we were using $modx-&gt;getService. The getService call would return a new instance because the earlier instance wasn''t created properly, meaning we would lose data added to $contentblocks-&gt;renames. <\/p><p>The fix for this was luckily easy, we just had to switch the connector to also use getService. <\/p>","field":2,"settings":[]},{"value":"<?php\n\/\/ ...\n$corePath = $modx->getOption(''contentblocks.core_path'', null, $modx->getOption(''core_path'') . ''components\/contentblocks\/'');\n$modx->getService(''contentblocks'', ''ContentBlocks'', $corePath . ''model\/contentblocks\/'');\n\/\/ ...","lang":"php","field":10,"settings":[]},{"value":"Step 2: Log the file name changes","level":"h3","field":3,"settings":[]},{"value":"<p>The next step is to listen to the OnFileManagerFileRename system event in MODX, and to log the new file name to our $contentblocks-&gt;renames array. To do this, we updated our existing plugin to also listen to that event and simply added the following to the code:<\/p>","field":2,"settings":[]},{"value":"<?php\n$corePath = $modx->getOption(''contentblocks.core_path'', null, $modx->getOption(''core_path'') . ''components\/contentblocks\/'');\n$contentblocks = $modx->getService(''contentblocks'', ''ContentBlocks'', $corePath . ''model\/contentblocks\/'');\n\nswitch ($modx->event->name) {\n    case ''OnFileManagerFileRename'':\n        $contentblocks->renames[] = $path;\n        break;\n        \n    \/\/ ...\n}\n","lang":"php","field":10,"settings":[]},{"value":"<p>This way, whenever a file is renamed, ContentBlocks is made aware of it. <\/p>","field":2,"settings":[]},{"value":"Step 3: Updating the Upload Code","level":"h3","field":3,"settings":[]},{"value":"<p>The third, and final, step is to update the upload code to check for file renames. Here''s what that looks like for ContentBlocks:<\/p>","field":2,"settings":[]},{"value":"<?php\n\nclass ContentBlocksImageUploadProcessor extends ContentBlocksImageProcessor {\n    \/**\n     * @return bool\n     *\/\n    public function process() {\n        \/\/ ... bunch of preprocessing here\n        \n        \/**\n         * Do the upload\n         *\/\n        $this->contentblocks->renames = array();\n        $uploaded = $this->source->uploadObjectsToContainer($this->path, $_FILES);\n        if (!$uploaded) {\n            $errors = $this->source->getErrors();\n            $errors = implode(''<br \/>'', $errors);\n            return $this->failure($errors);\n        }\n        \/**\n         * Check if the file has been renamed by a plugin like FileSluggy\n         *\/\n        $newFileName = reset($this->contentblocks->renames);\n        if (!empty($newFileName)) {\n            $baseMediaPath = $this->source->getBasePath() . $this->path;\n            $newFileName = substr($newFileName, strlen($baseMediaPath));\n            $_FILES[''file''][''name''] = $newFileName;\n        }\n        \n        \/\/ ... and more processing here\n    }\n}","lang":"php","field":10,"settings":[]},{"value":"<p>Obviously this is just a small snippet of the upload processor. The key lines are<\/p>","field":2,"settings":[]}],"fieldcounts":{"2":10,"3":5,"10":5},"_isContentBlocks":true}}'
tvs:
    author: markhamstra
    disqus_id: ''
    preview.image: ''

-----

<div class="row   " >
    <div class="[[++default_article_column_classnames]]">
        <p>At modmore we have 3 extras that use file uploads one way or another: ContentBlocks, Redactor and MoreGallery. The file upload utilities in these extras have all been built with the Media Sources API in MODX, allowing them to support different media source configurations, remote sources like Amazon S3 and plugins that fire on upload.</p><p>Unfortunately, some of those plugins change the name of the uploaded file (for sanitisation or SEO purposes), and for a long time we've been unable of supporting those plugins, like FileSluggy and filetranslit. </p>

<h2>The Problem</h2>

<p>In our code, we call $source-&gt;uploadObjectsToContainer() with a prepared files array, and the path we determined it should go to inside the media source. The media source, whether that's the file or Amazon S3 one, then takes care of the actual upload and returns a true (successful upload) or false (something went wrong). </p><p>As the upload happens, the OnFileManagerUpload event is fired by MODX, and plugins like FileSluggy are executed. If they determine the filename does not meet their requirements (for example it contains dashes, while underscores are preferred), the plugin calls $source-&gt;renameObject() with a new file name. This is where the problem happens, as our code doesn't get a message that the file name was changed after upload. So we try to show an image with a name that no longer exists. Broken image. </p><p>For a long time we were unable of figuring out a workaround, until the guys at Sterc walked into modmore hq to check on the issue. Following a bit of a discussion and some source code digging, an epiphany happened and we finally found a fix. Since then we've updated our extras to fix the compatibility. As there might be other people out there (today or in six months from now) that need to deal with the same problem, I'd like to present you our solution. </p>

<h2>The Solution</h2>

<p>As with all issues that take ages to solve, the solution is pretty simple: listen for renamed files.</p><p>In the same fashion that MODX fires an event on upload in $source-&gt;uploadObjectsToContainer(), it also fires an event when a file is renamed through $source-&gt;renameObject(). We can listen for this event in a plugin, store the updated file name, and check if any file renames happened during the upload. </p><p>Here's how we fixed this, taking ContentBlocks as the example.</p>

<h3>Step 1: Add a place to store changed filenames</h3>

<p>The most obvious place to store changed file names is on the service class. Pretty much all MODX Extras have one with the same name as the package. As a service class, we can also use $modx-&gt;getService() to always get the same instance - rather than creating a new copy every time - so we can store our changed file name there temporarily. </p><p>For this purpose we added a simple $renames array.</p>

<pre><code class="language-php">&lt;?php

class ContentBlocks {
    public $renames = array();
    
    public function __construct(modX $modx, array $config = array()) {
        // ...
    }
}</code></pre>

<p>If you're feeling fancy, you might add a getter and setter for it, but we just made it public instead.</p><p>After adding it to the class we can start interacting with it, however it's important that we share the same instance across the request. In our case, we had a direct instantiation in assets/components/contentblocks/connector.php like this:</p>

<pre><code class="language-php">&lt;?php
// ...
$corePath = $modx-&gt;getOption('contentblocks.core_path', null, $modx-&gt;getOption('core_path') . 'components/contentblocks/');
require_once $corePath.'model/contentblocks/contentblocks.class.php';
$modx-&gt;contentblocks = new ContentBlocks($modx);
// ...</code></pre>

<p>whereas elsewhere in the code, such as in our plugin as we'll see in a bit, we were using $modx-&gt;getService. The getService call would return a new instance because the earlier instance wasn't created properly, meaning we would lose data added to $contentblocks-&gt;renames. </p><p>The fix for this was luckily easy, we just had to switch the connector to also use getService. </p>

<pre><code class="language-php">&lt;?php
// ...
$corePath = $modx-&gt;getOption('contentblocks.core_path', null, $modx-&gt;getOption('core_path') . 'components/contentblocks/');
$modx-&gt;getService('contentblocks', 'ContentBlocks', $corePath . 'model/contentblocks/');
// ...</code></pre>

<h3>Step 2: Log the file name changes</h3>

<p>The next step is to listen to the OnFileManagerFileRename system event in MODX, and to log the new file name to our $contentblocks-&gt;renames array. To do this, we updated our existing plugin to also listen to that event and simply added the following to the code:</p>

<pre><code class="language-php">&lt;?php
$corePath = $modx-&gt;getOption('contentblocks.core_path', null, $modx-&gt;getOption('core_path') . 'components/contentblocks/');
$contentblocks = $modx-&gt;getService('contentblocks', 'ContentBlocks', $corePath . 'model/contentblocks/');

switch ($modx-&gt;event-&gt;name) {
    case 'OnFileManagerFileRename':
        $contentblocks-&gt;renames&#91;&#93; = $path;
        break;
        
    // ...
}
</code></pre>

<p>This way, whenever a file is renamed, ContentBlocks is made aware of it. </p>

<h3>Step 3: Updating the Upload Code</h3>

<p>The third, and final, step is to update the upload code to check for file renames. Here's what that looks like for ContentBlocks:</p>

<pre><code class="language-php">&lt;?php

class ContentBlocksImageUploadProcessor extends ContentBlocksImageProcessor {
    /**
     * @return bool
     */
    public function process() {
        // ... bunch of preprocessing here
        
        /**
         * Do the upload
         */
        $this-&gt;contentblocks-&gt;renames = array();
        $uploaded = $this-&gt;source-&gt;uploadObjectsToContainer($this-&gt;path, $_FILES);
        if (!$uploaded) {
            $errors = $this-&gt;source-&gt;getErrors();
            $errors = implode('&lt;br /&gt;', $errors);
            return $this-&gt;failure($errors);
        }
        /**
         * Check if the file has been renamed by a plugin like FileSluggy
         */
        $newFileName = reset($this-&gt;contentblocks-&gt;renames);
        if (!empty($newFileName)) {
            $baseMediaPath = $this-&gt;source-&gt;getBasePath() . $this-&gt;path;
            $newFileName = substr($newFileName, strlen($baseMediaPath));
            $_FILES&#91;'file'&#93;&#91;'name'&#93; = $newFileName;
        }
        
        // ... and more processing here
    }
}</code></pre>

<p>Obviously this is just a small snippet of the upload processor. The key lines are</p>
    </div>
</div>