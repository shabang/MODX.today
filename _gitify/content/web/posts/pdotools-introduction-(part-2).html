id: 440
pagetitle: 'pdoTools Introduction (Part 2)'
alias: pdotools-introduction-(part-2)
parent: 1
introtext: ''
template: 2
menuindex: 282
createdby: 2
uri: posts/pdotools-introduction-(part-2)
show_in_tree: 0
properties: '{"contentblocks":{"content":"[{\"layout\":3,\"content\":{\"col1\":[{\"value\":\"<p>As we learned in the first post about pdoTools, the main benefit of pdoTools is speed. In this second post we''ll look at how pdoTools can be faster, and some more cool features that the library provides. <\/p><p>I developed the first version of pdoTools when working on Tickets. It was supposed to be a ticketing system, but when it was complete it was more like a simple blog system with awesome AJAX commenting. Tools like getResources were not fast enough, so I developed by own library. <\/p><p>The speed in pdoTools come from two ideas. <\/p><ol><li>The database query is built with xPDO, but executed directly with PDO. This means there are no objects created to represent the rows in the database.<\/li><li>Faster chunk processing. If pdoTools can parse the chunk itself, the standard MODX parser is not used. <\/li><\/ol><p>To achieve this there are two classes in pdoTools. <strong>pdoTools<\/strong> is the primary class with general methods for parsing chunks, using placeholders, caching etc. <strong>pdoFetch<\/strong> is the class that works with the database. This can be used to build and execute queries, and to return the results. <\/p>\",\"field\":2,\"settings\":[]},{\"value\":\"pdoFetch\",\"level\":\"h2\",\"field\":3,\"settings\":[]},{\"value\":\"<p>pdoFetch extends the pdoTools class, so you only need to load the one class depending on what you need to do. To load the pdoFetch class, you can just do this:<\/p>\",\"field\":2,\"settings\":[]},{\"value\":\"<?php\\n$pdo = $modx->getService(''pdoFetch'');\",\"lang\":\"php\",\"field\":10,\"settings\":[]},{\"value\":\"<p>After that you can use all the functions, for example getCollection and getChunk. Here is an example on retrieving and processing resources.<\/p>\",\"field\":2,\"settings\":[]},{\"value\":\"<?php\\n$pdo = $modx->getService(''pdoFetch'');\\n$resources = $pdo->getCollection(''modResource'', array(\\n    ''published'' => true,\\n    ''deleted'' => false\\n), array(\\n    ''parents'' => ''1,5,6,-9'',\\n    ''includeTVs'' => ''tv1, tv2'',\\n    ''sortby'' => ''id'',\\n    ''sortby'' => ''asc'',\\n    ''limit'' => 20,\\n));\\n$tpl = ''@INLINE <p>[[+id]] - [[+pagetitle]]<\/p>'';\\n$output = '''';\\nforeach ($resources as $resource) {\\n    $output .= $pdo->getChunk($tpl, $resource);\\n}\\nreturn $output;\",\"lang\":\"php\",\"field\":10,\"settings\":[]},{\"value\":\"<p>All the logic of the pdoResources snippet is actually inside the pdoFetch class, so you can use that in your own snippets. <\/p><p>pdoFetch tries to execute only a single query at a time. So you need to join tables if you want information that is not in the requested table. <\/p><p>The only time when additional queries are made is when the TVs are selected because we need to get their names and default values for proper requests. After that TVs are joined in the main query, so there are no additional queries to get those values. <\/p><p>If you want to filter by TVs, you can use the <code>&where<\/code> property for it. <\/p>\",\"field\":2,\"settings\":[]},{\"value\":\"[[!pdoResources?\\n    &parents=`0`\\n    &includeTVs=`tv1`\\n    &where=`{\\\"tv1\\\":\\\"my_value\\\"}`\\n]]\",\"lang\":\"html\",\"field\":10,\"settings\":{}},{\"value\":\"<p>As TVs using the default value are not stored as values in the database, you need to compare the value to <code>null<\/code> when you want to select those resources. So if you want to get all resources where tv2 is set to the default value, you would do it like this:<\/p>\",\"field\":2,\"settings\":{}},{\"value\":\"[[!pdoResources?\\n    &parents=`0`\\n    &includeTVs=`tv2`\\n    &where=`{\\\"tv2\\\":null}`\\n]]\",\"lang\":\"html\",\"field\":10,\"settings\":{}},{\"value\":\"<p>In the template it will return the right default value for you to use. <\/p><p>Hopefully this explains pdoFetch and how you can use it. To summarise:<\/p><ol><li>All data is collected in a single query.<\/li><li>Use table joins for getting additional data from other tables if needed. <\/li><li>The results are returned as arrays instead of xPDO objects<\/li><li>If you enable <code>&checkPermissions<\/code> objects will be created to use the <code>checkPolicy()<\/code> method to make sure the user has permissions.<\/li><\/ol>\",\"field\":2,\"settings\":{}}]},\"settings\":[],\"parent\":0,\"title\":\"\"}]","linear":[{"value":"<p>As we learned in the first post about pdoTools, the main benefit of pdoTools is speed. In this second post we''ll look at how pdoTools can be faster, and some more cool features that the library provides. <\/p><p>I developed the first version of pdoTools when working on Tickets. It was supposed to be a ticketing system, but when it was complete it was more like a simple blog system with awesome AJAX commenting. Tools like getResources were not fast enough, so I developed by own library. <\/p><p>The speed in pdoTools come from two ideas. <\/p><ol><li>The database query is built with xPDO, but executed directly with PDO. This means there are no objects created to represent the rows in the database.<\/li><li>Faster chunk processing. If pdoTools can parse the chunk itself, the standard MODX parser is not used. <\/li><\/ol><p>To achieve this there are two classes in pdoTools. <strong>pdoTools<\/strong> is the primary class with general methods for parsing chunks, using placeholders, caching etc. <strong>pdoFetch<\/strong> is the class that works with the database. This can be used to build and execute queries, and to return the results. <\/p>","field":2,"settings":[]},{"value":"pdoFetch","level":"h2","field":3,"settings":[]},{"value":"<p>pdoFetch extends the pdoTools class, so you only need to load the one class depending on what you need to do. To load the pdoFetch class, you can just do this:<\/p>","field":2,"settings":[]},{"value":"<?php\n$pdo = $modx->getService(''pdoFetch'');","lang":"php","field":10,"settings":[]},{"value":"<p>After that you can use all the functions, for example getCollection and getChunk. Here is an example on retrieving and processing resources.<\/p>","field":2,"settings":[]},{"value":"<?php\n$pdo = $modx->getService(''pdoFetch'');\n$resources = $pdo->getCollection(''modResource'', array(\n    ''published'' => true,\n    ''deleted'' => false\n), array(\n    ''parents'' => ''1,5,6,-9'',\n    ''includeTVs'' => ''tv1, tv2'',\n    ''sortby'' => ''id'',\n    ''sortby'' => ''asc'',\n    ''limit'' => 20,\n));\n$tpl = ''@INLINE <p>[[+id]] - [[+pagetitle]]<\/p>'';\n$output = '''';\nforeach ($resources as $resource) {\n    $output .= $pdo->getChunk($tpl, $resource);\n}\nreturn $output;","lang":"php","field":10,"settings":[]},{"value":"<p>All the logic of the pdoResources snippet is actually inside the pdoFetch class, so you can use that in your own snippets. <\/p><p>pdoFetch tries to execute only a single query at a time. So you need to join tables if you want information that is not in the requested table. <\/p><p>The only time when additional queries are made is when the TVs are selected because we need to get their names and default values for proper requests. After that TVs are joined in the main query, so there are no additional queries to get those values. <\/p><p>If you want to filter by TVs, you can use the <code>&where<\/code> property for it. <\/p>","field":2,"settings":[]},{"value":"[[!pdoResources?\n    &parents=`0`\n    &includeTVs=`tv1`\n    &where=`{\"tv1\":\"my_value\"}`\n]]","lang":"html","field":10,"settings":[]},{"value":"<p>As TVs using the default value are not stored as values in the database, you need to compare the value to <code>null<\/code> when you want to select those resources. So if you want to get all resources where tv2 is set to the default value, you would do it like this:<\/p>","field":2,"settings":[]},{"value":"[[!pdoResources?\n    &parents=`0`\n    &includeTVs=`tv2`\n    &where=`{\"tv2\":null}`\n]]","lang":"html","field":10,"settings":[]},{"value":"<p>In the template it will return the right default value for you to use. <\/p><p>Hopefully this explains pdoFetch and how you can use it. To summarise:<\/p><ol><li>All data is collected in a single query.<\/li><li>Use table joins for getting additional data from other tables if needed. <\/li><li>The results are returned as arrays instead of xPDO objects<\/li><li>If you enable <code>&checkPermissions<\/code> objects will be created to use the <code>checkPolicy()<\/code> method to make sure the user has permissions.<\/li><\/ol>","field":2,"settings":[]}],"fieldcounts":{"2":6,"3":1,"10":4},"_isContentBlocks":true}}'
tvs:
    author: vasilynaumkin
    disqus_id: ''
    preview.image: ''

-----

<div class="row   " >
    <div class="[[++default_article_column_classnames]]">
        <p>As we learned in the first post about pdoTools, the main benefit of pdoTools is speed. In this second post we'll look at how pdoTools can be faster, and some more cool features that the library provides. </p><p>I developed the first version of pdoTools when working on Tickets. It was supposed to be a ticketing system, but when it was complete it was more like a simple blog system with awesome AJAX commenting. Tools like getResources were not fast enough, so I developed by own library. </p><p>The speed in pdoTools come from two ideas. </p><ol><li>The database query is built with xPDO, but executed directly with PDO. This means there are no objects created to represent the rows in the database.</li><li>Faster chunk processing. If pdoTools can parse the chunk itself, the standard MODX parser is not used. </li></ol><p>To achieve this there are two classes in pdoTools. <strong>pdoTools</strong> is the primary class with general methods for parsing chunks, using placeholders, caching etc. <strong>pdoFetch</strong> is the class that works with the database. This can be used to build and execute queries, and to return the results. </p>

<h2>pdoFetch</h2>

<p>pdoFetch extends the pdoTools class, so you only need to load the one class depending on what you need to do. To load the pdoFetch class, you can just do this:</p>

<pre><code class="language-php">&lt;?php
$pdo = $modx-&gt;getService('pdoFetch');</code></pre>

<p>After that you can use all the functions, for example getCollection and getChunk. Here is an example on retrieving and processing resources.</p>

<pre><code class="language-php">&lt;?php
$pdo = $modx-&gt;getService('pdoFetch');
$resources = $pdo-&gt;getCollection('modResource', array(
    'published' =&gt; true,
    'deleted' =&gt; false
), array(
    'parents' =&gt; '1,5,6,-9',
    'includeTVs' =&gt; 'tv1, tv2',
    'sortby' =&gt; 'id',
    'sortby' =&gt; 'asc',
    'limit' =&gt; 20,
));
$tpl = '@INLINE &lt;p&gt;&#91;&#91;+id&#93;&#93; - &#91;&#91;+pagetitle&#93;&#93;&lt;/p&gt;';
$output = '';
foreach ($resources as $resource) {
    $output .= $pdo-&gt;getChunk($tpl, $resource);
}
return $output;</code></pre>

<p>All the logic of the pdoResources snippet is actually inside the pdoFetch class, so you can use that in your own snippets. </p><p>pdoFetch tries to execute only a single query at a time. So you need to join tables if you want information that is not in the requested table. </p><p>The only time when additional queries are made is when the TVs are selected because we need to get their names and default values for proper requests. After that TVs are joined in the main query, so there are no additional queries to get those values. </p><p>If you want to filter by TVs, you can use the <code>&where</code> property for it. </p>

<pre><code class="language-markup">&#91;&#91;!pdoResources?
    &amp;parents=`0`
    &amp;includeTVs=`tv1`
    &amp;where=`{&quot;tv1&quot;:&quot;my_value&quot;}`
&#93;&#93;</code></pre>

<p>As TVs using the default value are not stored as values in the database, you need to compare the value to <code>null</code> when you want to select those resources. So if you want to get all resources where tv2 is set to the default value, you would do it like this:</p>

<pre><code class="language-markup">&#91;&#91;!pdoResources?
    &amp;parents=`0`
    &amp;includeTVs=`tv2`
    &amp;where=`{&quot;tv2&quot;:null}`
&#93;&#93;</code></pre>

<p>In the template it will return the right default value for you to use. </p><p>Hopefully this explains pdoFetch and how you can use it. To summarise:</p><ol><li>All data is collected in a single query.</li><li>Use table joins for getting additional data from other tables if needed. </li><li>The results are returned as arrays instead of xPDO objects</li><li>If you enable <code>&checkPermissions</code> objects will be created to use the <code>checkPolicy()</code> method to make sure the user has permissions.</li></ol>
    </div>
</div>